## -*- tcl -*-
# # ## ### ##### ######## ############# #####################
## Test suite for struct::queue, common parts across implementations.
#
## Two complementary constraints (queue_c, queue_tcl) tell us
## which implementation is under test.
#
## The external procedures 'already' and 'badmethod' are used to
## generate implementation specific error messages. Implementations
## have to be provided by the invoking implementation-specific
## testsuite.

# # ## ### ##### ######## ############# #####################

test queue-1.0.1 {new, wrong#args, too many} -constraints queue_c -body {
    struct queue new X
} -returnCodes error -result {wrong # args: should be "struct queue new"}

test queue-1.1.0 {create, wrong#args, too many} -constraints queue_c -body {
    struct queue create foo X
} -returnCodes error -result {wrong # args: should be "::struct::queue create foo"}

## !! Note how we are not using the ensemble.
## Tcl generates a broken error message if we do.
test queue-1.0.1 {new, wrong#args, too many} -constraints queue_tcl -body {
    struct::queue new X
} -returnCodes error -result {wrong # args: should be "struct::queue new"}

test queue-1.1.1 {create, wrong#args, too many} -constraints queue_tcl -body {
    struct::queue create foo X
} -returnCodes error -result {wrong # args: should be "struct::queue create foo"}

test queue-1.2 {constructor, create, existing command} -setup {
    struct queue create myqueue
} -body {
    struct queue create myqueue
} -cleanup {
    myqueue destroy
} -returnCodes error -result [already myqueue]

test queue-1.3 {constructor, create, existing command} -body {
    struct queue create set
} -returnCodes error -result [already set]

test queue-1.4 {constructor, create} -setup {
    set result {}
} -body {
    lappend result [struct queue create myqueue]
    lappend result [info commands ::myqueue]
    lappend result [myqueue size]
} -cleanup {
    myqueue destroy
    unset result
} -result {::myqueue ::myqueue 0}

test queue-1.5.0 {constructor, new} -constraints queue_c -setup {
    set result {}
} -body {
    lappend result [set foo [struct queue new]]
    lappend result [info commands ::$foo]
    lappend result [$foo size]
} -cleanup {
    $foo destroy
    unset result foo
} -match glob -result {::struct::queue* ::struct::queue* 0}

test queue-1.5.1 {constructor, new} -constraints queue_tcl -setup {
    set result {}
} -body {
    lappend result [set foo [struct queue new]]
    lappend result [info commands ::$foo]
    lappend result [$foo size]
} -cleanup {
    $foo destroy
    unset result foo
} -match glob -result {::oo::Obj* ::oo::Obj* 0}

# # ## ### ##### ######## ############# #####################

test queue-2.0.0 {instance, no method} -constraints queue_c -setup {
    struct queue create myqueue
} -body {
    myqueue
} -cleanup {
    myqueue destroy
} -returnCodes error \
    -result {wrong # args: should be "myqueue option ?arg arg ...?"}

test queue-2.0.1 {instance, no method} -constraints queue_tcl -setup {
    struct queue create myqueue
} -body {
    myqueue
} -cleanup {
    myqueue destroy
} -returnCodes error \
    -result {wrong # args: should be "myqueue method ?arg ...?"}

test queue-2.1 {instance, bad method name} -setup {
    struct queue create myqueue
} -body {
    myqueue foo
} -cleanup {
    myqueue destroy
} -returnCodes error \
    -result [badmethod foo {append clear destroy get head pop prepend size tail}]

# # ## ### ##### ######## ############# #####################

test queue-3.0 {destroy, wrong#args, too many} -setup {
    struct queue create myqueue
} -body {
    myqueue destroy X
} -cleanup {
    myqueue destroy
} -returnCodes error -result {wrong # args: should be "myqueue destroy"}

test queue-3.1 {destroy} -setup {
    struct queue create myqueue
} -body {
    myqueue destroy
    info commands ::myqueue
} -result {}

# # ## ### ##### ######## ############# #####################

test queue-4.0 {size, wrong#args, too many} -setup {
    struct queue create myqueue
} -body {
    myqueue size X
} -cleanup {
    myqueue destroy
} -returnCodes error -result {wrong # args: should be "myqueue size"}

test queue-4.1 {size} -setup {
    struct queue create myqueue
    myqueue append a b c d e f g
} -body {
    myqueue size
} -cleanup {
    myqueue destroy
} -result 7

test queue-4.2 {size} -setup {
    struct queue create myqueue
    myqueue append a b c d e f g
    myqueue pop head 3
} -body {
   myqueue size
} -cleanup {
    myqueue destroy
} -result 4

test queue-4.3 {size} -setup {
    struct queue create myqueue
    myqueue append a b c d e f g
    myqueue pop head 3
    myqueue head 3
} -body {
  myqueue size
} -cleanup {
    myqueue destroy
} -result 4

# # ## ### ##### ######## ############# #####################

test queue-5.0 {head, wrong#args, too many} -setup {
    struct queue create myqueue
} -body {
    myqueue head X Y
} -cleanup {
    myqueue destroy
} -returnCodes error -result {wrong # args: should be "myqueue head ?n?"}

test queue-5.1 {head, bad size} -setup {
    struct queue create myqueue
} -body {
    myqueue head X
} -cleanup {
    myqueue destroy
} -returnCodes error -result {expected positive integer but got "X"}

test queue-5.2 {head, bad size} -setup {
    struct queue create myqueue
} -body {
    myqueue head 0
} -cleanup {
    myqueue destroy
} -returnCodes error -result {expected positive integer but got "0"}

test queue-5.3 {head, bad size} -setup {
    struct queue create myqueue
    myqueue append a b c d
} -body {
    myqueue head 5
} -cleanup {
    myqueue destroy
} -returnCodes error -result {not enough elements}

test queue-5.4 {head, bad size} -setup {
    struct queue create myqueue
    myqueue append a b c d
} -body {
    myqueue head -1
} -cleanup {
    myqueue destroy
} -returnCodes error -result {expected positive integer but got "-1"}

test queue-5.5 {head, bad size} -setup {
    struct queue create myqueue
} -body {
    myqueue head
} -cleanup {
    myqueue destroy
} -returnCodes error -result {not enough elements}

# The tricky thing about head and the others is to create all the
# possible states the internal queue buffers can be in, so that we
# actual cover all the branches.
#
# TODO: Break abstraction and introspect the C and Tcl instance
#       variables ?

test queue-5.6 {head, single, tail} -setup {
    struct queue create myqueue
    myqueue append a b c d
} -body {
    myqueue head
} -cleanup {
    myqueue destroy
} -result a

test queue-5.7 {head, single, head} -setup {
    struct queue create myqueue
    myqueue prepend a b c d
} -body {
    myqueue head
} -cleanup {
    myqueue destroy
} -result d

test queue-5.8 {head, single, middle} -setup {
    struct queue create myqueue
    myqueue append a b c d
    myqueue pop head ; # Should shift tail -> middle.
} -body {
    myqueue head
} -cleanup {
    myqueue destroy
} -result b

test queue-5.9 {head, multi, tail} -setup {
    struct queue create myqueue
    myqueue append a b c d
} -body {
    myqueue head 2
} -cleanup {
    myqueue destroy
} -result {a b}

test queue-5.10 {head, multi, head} -setup {
    struct queue create myqueue
    myqueue prepend a b c d
} -body {
    myqueue head 2
} -cleanup {
    myqueue destroy
} -result {d c}

test queue-5.11 {head, multi, middle} -setup {
    struct queue create myqueue
    myqueue append a b c d
    myqueue pop head ; # Should shift tail -> middle.
} -body {
    myqueue head 2
} -cleanup {
    myqueue destroy
} -result {b c}

foreach {k take result} {
    12  5 {l k j i a}
    13  6 {l k j i a b}
    14  7 {l k j i a b c}
    15  8 {l k j i a b c d}
    16  9 {l k j i a b c d e}
    17 10 {l k j i a b c d e f}
    18 11 {l k j i a b c d e f g}
    19 12 {l k j i a b c d e f g h}
} {
    test queue-5.$k {head, span} -setup {
	struct queue create myqueue
	myqueue append _ a b c d
	myqueue pop head ; # put tail into middle
	myqueue append  e f g h ; # new tail
	myqueue prepend i j k l ; # and head
    } -body {
	myqueue head $take
    } -cleanup {
	myqueue destroy
    } -result $result
}
# # ## ### ##### ######## ############# #####################

test queue-6.0 {tail, wrong#args, too many} -setup {
    struct queue create myqueue
} -body {
    myqueue tail X Y
} -cleanup {
    myqueue destroy
} -returnCodes error -result {wrong # args: should be "myqueue tail ?n?"}

test queue-6.1 {tail, bad size} -setup {
    struct queue create myqueue
} -body {
    myqueue tail X
} -cleanup {
    myqueue destroy
} -returnCodes error -result {expected positive integer but got "X"}

test queue-6.2 {tail, bad size} -setup {
    struct queue create myqueue
} -body {
    myqueue tail 0
} -cleanup {
    myqueue destroy
} -returnCodes error -result {expected positive integer but got "0"}

test queue-6.3 {tail, bad size} -setup {
    struct queue create myqueue
    myqueue append a b c d
} -body {
    myqueue tail 5
} -cleanup {
    myqueue destroy
} -returnCodes error -result {not enough elements}

test queue-6.4 {tail, bad size} -setup {
    struct queue create myqueue
    myqueue append a b c d
} -body {
    myqueue tail -1
} -cleanup {
    myqueue destroy
} -returnCodes error -result {expected positive integer but got "-1"}

test queue-6.5 {tail, bad size} -setup {
    struct queue create myqueue
} -body {
    myqueue tail
} -cleanup {
    myqueue destroy
} -returnCodes error -result {not enough elements}

# The tricky thing about tail and the others is to create all the
# possible states the internal queue buffers can be in, so that we
# actual cover all the branches.
#
# TODO: Break abstraction and introspect the C and Tcl instance
#       variables ?

test queue-6.6 {tail, single, head} -setup {
    struct queue create myqueue
    myqueue prepend a b c d
} -body {
    myqueue tail
} -cleanup {
    myqueue destroy
} -result a

test queue-6.7 {tail, single, tail} -setup {
    struct queue create myqueue
    myqueue append a b c d
} -body {
    myqueue tail
} -cleanup {
    myqueue destroy
} -result d

test queue-6.8 {tail, single, middle} -setup {
    struct queue create myqueue
    myqueue append a b c d
    myqueue pop head ; # Should shift tail -> middle.
} -body {
    myqueue tail
} -cleanup {
    myqueue destroy
} -result d

test queue-6.9 {tail, multi, head} -setup {
    struct queue create myqueue
    myqueue prepend a b c d
} -body {
    myqueue tail 2
} -cleanup {
    myqueue destroy
} -result {b a}

test queue-6.10 {tail, multi, tail} -setup {
    struct queue create myqueue
    myqueue append a b c d
} -body {
    myqueue tail 2
} -cleanup {
    myqueue destroy
} -result {c d}

test queue-6.11 {tail, multi, middle} -setup {
    struct queue create myqueue
    myqueue append a b c d
    myqueue pop head ; # Should shift tail -> middle.
} -body {
    myqueue tail 2
} -cleanup {
    myqueue destroy
} -result {c d}

foreach {k take result} {
    12  5 {d e f g h}
    13  6 {c d e f g h}
    14  7 {b c d e f g h}
    15  8 {a b c d e f g h}
    16  9 {i a b c d e f g h}
    17 10 {j i a b c d e f g h}
    18 11 {k j i a b c d e f g h}
    19 12 {l k j i a b c d e f g h}
} {
    test queue-6.$k {tail, span} -setup {
	struct queue create myqueue
	myqueue append _ a b c d
	myqueue pop head ; # put tail into middle
	myqueue append  e f g h ; # new tail
	myqueue prepend i j k l ; # and head
    } -body {
	myqueue tail $take
    } -cleanup {
	myqueue destroy
    } -result $result
}

# # ## ### ##### ######## ############# #####################
return



#----------------------------------------------------------------------
    
test queue-4.1 {put operation} {
    queue myqueue
    catch {myqueue put} msg
    myqueue destroy
    set msg
} "wrong # args: should be \"myqueue put item ?item ...?\""

test queue-4.2 {put operation, singleton items} {
    queue myqueue
    myqueue put a
    myqueue put b
    myqueue put c
    set result [list [myqueue get] [myqueue get] [myqueue get]]
    myqueue destroy
    set result
} {a b c}

test queue-4.3 {put operation, multiple items} {
    queue myqueue
    myqueue put a b c
    set result [list [myqueue get] [myqueue get] [myqueue get]]
    myqueue destroy
    set result
} {a b c}

test queue-4.4 {put operation, spaces in items} {
    queue myqueue
    myqueue put a b "foo bar"
    set result [list [myqueue get] [myqueue get] [myqueue get]]
    myqueue destroy
    set result
} {a b {foo bar}}

test queue-4.5 {put operation, bad chars in items} {
    queue myqueue
    myqueue put a b \{
    set result [list [myqueue get] [myqueue get] [myqueue get]]
    myqueue destroy
    set result
} [list a b \{]

#----------------------------------------------------------------------

test queue-5.1 {get operation} {
    queue myqueue
    myqueue put a
    myqueue put b
    myqueue put c
    set result [list [myqueue get] [myqueue get] [myqueue get]]
    myqueue destroy
    set result
} {a b c}

test queue-5.2 {get operation, multiple items} {
    queue myqueue
    myqueue put a
    myqueue put b
    myqueue put c
    set result [myqueue get 3]
    myqueue destroy
    set result
} {a b c}

test queue-6.6 {get operation, multiple items} {
    queue myqueue
    myqueue put a
    myqueue put b
    myqueue put c
    set result [list [myqueue peek 3] [myqueue get 3]]
    myqueue destroy
    set result
} {{a b c} {a b c}}

test queue-6.7 {get operation} {
    queue myqueue
    catch {myqueue get 0} msg
    myqueue destroy
    set msg
} {invalid item count 0}

test queue-6.8 {get operation} {
    queue myqueue
    catch {myqueue get -1} msg
    myqueue destroy
    set msg
} {invalid item count -1}

test queue-6.9 {get operation} {
    queue myqueue
    catch {myqueue get} msg
    myqueue destroy
    set msg
} {insufficient items in queue to fill request}

test queue-6.10 {get operation} {
    queue myqueue
    myqueue put a
    catch {myqueue get 2} msg
    myqueue destroy
    set msg
} {insufficient items in queue to fill request}

#----------------------------------------------------------------------

test queue-7.1 {clear operation} {
    queue myqueue
    myqueue put a
    myqueue put b
    myqueue put c
    set result [list [myqueue peek 3]]
    myqueue clear
    lappend result [myqueue size]
    myqueue destroy
    set result
} {{a b c} 0}

#----------------------------------------------------------------------

test queue-8.1 {unget operation, not enough arguments} {
    queue myqueue
    catch {myqueue unget} msg
    myqueue destroy
    set msg
} [tmWrong unget {item} 0]

test queue-8.2 {unget operation, too many arguments} {
    queue myqueue
    catch {myqueue unget a b} msg
    myqueue destroy
    set msg
} [tmTooMany unget {item}]

test queue-8.3 {unget, empty queue} {
    queue myqueue
    myqueue unget foo
    set res [myqueue peek [myqueue size]]
    myqueue destroy
    set res
} {foo}

test queue-8.4 {unget, nonempty queue, at beginning of queue} {
    queue myqueue
    myqueue put a b c
    myqueue unget foo
    set res [myqueue peek [myqueue size]]
    myqueue destroy
    set res
} {foo a b c}

test queue-8.5 {unget, nonempty queue, middle of queue} {
    queue myqueue
    myqueue put a b c d e f
    myqueue get 3
    myqueue unget foo
    set res [myqueue peek [myqueue size]]
    myqueue destroy
    set res
} {foo d e f}

#----------------------------------------------------------------------
