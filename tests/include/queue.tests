## -*- tcl -*-
# # ## ### ##### ######## ############# #####################
## Test suite for struct::queue, common parts across implementations.
#
## Two complementary constraints (queue_c, queue_tcl) tell us
## which implementation is under test.
#
## The external procedures 'already' and 'badmethod' are used to
## generate implementation specific error messages. Implementations
## have to be provided by the invoking implementation-specific
## testsuite.

# # ## ### ##### ######## ############# #####################

test queue-1.0.1 {new, wrong#args, too many} -constraints queue_c -body {
    struct queue new X
} -returnCodes error -result {wrong # args: should be "struct queue new"}

test queue-1.1.0 {create, wrong#args, too many} -constraints queue_c -body {
    struct queue create foo X
} -returnCodes error -result {wrong # args: should be "::struct::queue create foo"}

## !! Note how we are not using the ensemble.
## Tcl generates a broken error message if we do.
test queue-1.0.1 {new, wrong#args, too many} -constraints queue_tcl -body {
    struct::queue new X
} -returnCodes error -result {wrong # args: should be "struct::queue new"}

test queue-1.1.1 {create, wrong#args, too many} -constraints queue_tcl -body {
    struct::queue create foo X
} -returnCodes error -result {wrong # args: should be "struct::queue create foo"}

test queue-1.2 {constructor, create, existing command} -setup {
    struct queue create myqueue
} -body {
    struct queue create myqueue
} -cleanup {
    myqueue destroy
} -returnCodes error -result [already myqueue]

test queue-1.3 {constructor, create, existing command} -body {
    struct queue create set
} -returnCodes error -result [already set]

test queue-1.4 {constructor, create} -setup {
    set result {}
} -body {
    lappend result [struct queue create myqueue]
    lappend result [info commands ::myqueue]
    lappend result [myqueue size]
} -cleanup {
    myqueue destroy
    unset result
} -result {::myqueue ::myqueue 0}

test queue-1.5.0 {constructor, new} -constraints queue_c -setup {
    set result {}
} -body {
    lappend result [set foo [struct queue new]]
    lappend result [info commands ::$foo]
    lappend result [$foo size]
} -cleanup {
    $foo destroy
    unset result foo
} -match glob -result {::struct::queue* ::struct::queue* 0}

test queue-1.5.1 {constructor, new} -constraints queue_tcl -setup {
    set result {}
} -body {
    lappend result [set foo [struct queue new]]
    lappend result [info commands ::$foo]
    lappend result [$foo size]
} -cleanup {
    $foo destroy
    unset result foo
} -match glob -result {::oo::Obj* ::oo::Obj* 0}

# # ## ### ##### ######## ############# #####################

test queue-2.0.0 {instance, no method} -constraints queue_c -setup {
    struct queue create myqueue
} -body {
    myqueue
} -cleanup {
    myqueue destroy
} -returnCodes error \
    -result {wrong # args: should be "myqueue option ?arg arg ...?"}

test queue-2.0.1 {instance, no method} -constraints queue_tcl -setup {
    struct queue create myqueue
} -body {
    myqueue
} -cleanup {
    myqueue destroy
} -returnCodes error \
    -result {wrong # args: should be "myqueue method ?arg ...?"}

test queue-2.1 {instance, bad method name} -setup {
    struct queue create myqueue
} -body {
    myqueue foo
} -cleanup {
    myqueue destroy
} -returnCodes error \
    -result [badmethod foo {}]

# # ## ### ##### ######## ############# #####################

test queue-3.0 {destroy, wrong#args, too many} -setup {
    struct queue create myqueue
} -body {
    myqueue destroy X
} -cleanup {
    myqueue destroy
} -returnCodes error -result {wrong # args: should be "myqueue destroy"}

test queue-3.1 {destroy} -setup {
    struct queue create myqueue
} -body {
    myqueue destroy
    info commands ::myqueue
} -result {}

# # ## ### ##### ######## ############# #####################

test queue-4.0 {size, wrong#args, too many} -setup {
    struct queue create myqueue
} -body {
    myqueue size X
} -cleanup {
    myqueue destroy
} -returnCodes error -result {wrong # args: should be "myqueue size"}

test queue-4.1 {size} -setup {
    struct queue create myqueue
    myqueue append a b c d e f g
} -body {
    myqueue size
} -cleanup {
    myqueue destroy
} -result 7

test queue-4.2 {size} -setup {
    struct queue create myqueue
    myqueue append a b c d e f g
    myqueue pop 3
} -body {
   myqueue size
} -cleanup {
    myqueue destroy
} -result 4

test queue-4.3 {size} -setup {
    struct queue create myqueue
    myqueue append a b c d e f g
    myqueue pop 3
    myqueue peek 3
} -body {
  myqueue size
} -cleanup {
    myqueue destroy
} -result 4

# # ## ### ##### ######## ############# #####################




#----------------------------------------------------------------------
    
test queue-4.1 {put operation} {
    queue myqueue
    catch {myqueue put} msg
    myqueue destroy
    set msg
} "wrong # args: should be \"$MY put item ?item ...?\""

test queue-4.2 {put operation, singleton items} {
    queue myqueue
    myqueue put a
    myqueue put b
    myqueue put c
    set result [list [myqueue get] [myqueue get] [myqueue get]]
    myqueue destroy
    set result
} {a b c}

test queue-4.3 {put operation, multiple items} {
    queue myqueue
    myqueue put a b c
    set result [list [myqueue get] [myqueue get] [myqueue get]]
    myqueue destroy
    set result
} {a b c}

test queue-4.4 {put operation, spaces in items} {
    queue myqueue
    myqueue put a b "foo bar"
    set result [list [myqueue get] [myqueue get] [myqueue get]]
    myqueue destroy
    set result
} {a b {foo bar}}

test queue-4.5 {put operation, bad chars in items} {
    queue myqueue
    myqueue put a b \{
    set result [list [myqueue get] [myqueue get] [myqueue get]]
    myqueue destroy
    set result
} [list a b \{]

#----------------------------------------------------------------------

test queue-5.1 {get operation} {
    queue myqueue
    myqueue put a
    myqueue put b
    myqueue put c
    set result [list [myqueue get] [myqueue get] [myqueue get]]
    myqueue destroy
    set result
} {a b c}

test queue-5.2 {get operation, multiple items} {
    queue myqueue
    myqueue put a
    myqueue put b
    myqueue put c
    set result [myqueue get 3]
    myqueue destroy
    set result
} {a b c}

#----------------------------------------------------------------------

test queue-6.1 {peek operation} {
    queue myqueue
    myqueue put a
    myqueue put b
    myqueue put c
    set result [list [myqueue peek] [myqueue peek] [myqueue peek]]
    myqueue destroy
    set result
} {a a a}

test queue-6.2 {peek operation} {
    queue myqueue
    catch {myqueue peek 0} msg
    myqueue destroy
    set msg
} {invalid item count 0}

test queue-6.3 {peek operation} {
    queue myqueue
    catch {myqueue peek -1} msg
    myqueue destroy
    set msg
} {invalid item count -1}

test queue-6.4 {peek operation} {
    queue myqueue
    catch {myqueue peek} msg
    myqueue destroy
    set msg
} {insufficient items in queue to fill request}

test queue-6.5 {peek operation} {
    queue myqueue
    myqueue put a
    catch {myqueue peek 2} msg
    myqueue destroy
    set msg
} {insufficient items in queue to fill request}

test queue-6.6 {get operation, multiple items} {
    queue myqueue
    myqueue put a
    myqueue put b
    myqueue put c
    set result [list [myqueue peek 3] [myqueue get 3]]
    myqueue destroy
    set result
} {{a b c} {a b c}}

test queue-6.7 {get operation} {
    queue myqueue
    catch {myqueue get 0} msg
    myqueue destroy
    set msg
} {invalid item count 0}

test queue-6.8 {get operation} {
    queue myqueue
    catch {myqueue get -1} msg
    myqueue destroy
    set msg
} {invalid item count -1}

test queue-6.9 {get operation} {
    queue myqueue
    catch {myqueue get} msg
    myqueue destroy
    set msg
} {insufficient items in queue to fill request}

test queue-6.10 {get operation} {
    queue myqueue
    myqueue put a
    catch {myqueue get 2} msg
    myqueue destroy
    set msg
} {insufficient items in queue to fill request}

#----------------------------------------------------------------------

test queue-7.1 {clear operation} {
    queue myqueue
    myqueue put a
    myqueue put b
    myqueue put c
    set result [list [myqueue peek 3]]
    myqueue clear
    lappend result [myqueue size]
    myqueue destroy
    set result
} {{a b c} 0}

#----------------------------------------------------------------------

test queue-8.1 {unget operation, not enough arguments} {
    queue myqueue
    catch {myqueue unget} msg
    myqueue destroy
    set msg
} [tmWrong unget {item} 0]

test queue-8.2 {unget operation, too many arguments} {
    queue myqueue
    catch {myqueue unget a b} msg
    myqueue destroy
    set msg
} [tmTooMany unget {item}]

test queue-8.3 {unget, empty queue} {
    queue myqueue
    myqueue unget foo
    set res [myqueue peek [myqueue size]]
    myqueue destroy
    set res
} {foo}

test queue-8.4 {unget, nonempty queue, at beginning of queue} {
    queue myqueue
    myqueue put a b c
    myqueue unget foo
    set res [myqueue peek [myqueue size]]
    myqueue destroy
    set res
} {foo a b c}

test queue-8.5 {unget, nonempty queue, middle of queue} {
    queue myqueue
    myqueue put a b c d e f
    myqueue get 3
    myqueue unget foo
    set res [myqueue peek [myqueue size]]
    myqueue destroy
    set res
} {foo d e f}

#----------------------------------------------------------------------
