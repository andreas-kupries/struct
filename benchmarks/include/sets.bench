## -*- tcl -*-
# # ## ### ##### ######## ############# #####################
## Tcl Benchmarks for "struct::set"
## (c) 2012 Andreas Kupries

# Called on by the benchmark entrypoints of both "setc" and "settcl".
# The procedure [id] returns a string telling us which entrypoint is
# in use.

#puts [join [info loaded] \n]

# # ## ### ##### ######## ############# #####################
## Helper commands.

proc makeN {n {times 1}} {
    set res {}
    for {set i 0} {$i < $times} {incr i} {
	for {set j 1} {$j <= $n} {incr j} {
	    lappend res $j
	}
    }
    return $res
}

# Select between configurations for quick overview vs full test

#set xtime {1 2}
#set xlen  {1 10 100}
set xtime {1 2 3}
set xlen  {1 10 100 1000}
#set xtime {1 2 3 4}
#set xlen  {1 10 100 1000 10000}

foreach times $xtime {
    foreach n $xlen {
	dict set sx $times $n [makeN $n $times]
	dict set sy $times $n [makeN $n $times]
    }
}

# The variables sx and sy contain the same sets, however as they are
# generated separately the underlying Tcl_Obj* will be distinct.

# ### ### ### ######### ######### ######### ###########################
## Benchmarks.

# * contains S e
# - create S ...
# - difference A B...
# * empty S
# * equal A B
# * exclude A e...
# * include A e...
# - intersect S...
# - intersect3 A B
# * size S
# - subset A B
# - superset A B
# - symdifference A B
# - union S...

# * add Svar S...
# - set Svar e...
# * subtract Svar S...
# - unset Svar e...

# ### ### ### ######### ######### ######### ###########################
## empty

bench -desc "set: empty, empty" -body {
    struct set empty {}
}

foreach times $xtime {
    foreach n $xlen {
	set s [dict get $sx $times $n]
	bench -desc "set: empty, !empty $times/$n" -body {
	    struct set empty $s 
	}
    }
}

# ### ### ### ######### ######### ######### ###########################
## size (cardinality)

foreach times $xtime {
    foreach n $xlen {
	set s [dict get $sx $times $n]
	bench -desc "set: size $times/$n" -body {
	    struct set size $s
	}
    }
}

# ### ### ### ######### ######### ######### ###########################
## contains

foreach times $xtime {
    foreach n $xlen {
	set s [dict get $sx $times $n]
	set nh [expr {$n >> 1}]

	bench -desc "set: contains, no $times/$n" -body {
	    struct set contains $s not-present
	}

	bench -desc "set: contains, yes/a $times/$n" -body {
	    struct set contains $s 1
	}

	bench -desc "set: contains, yes/b $times/$n" -body {
	    struct set contains $s $nh
	}

	bench -desc "set: contains, yes/c $times/$n" -body {
	    struct set contains $s $n
	}
    }
}

# ### ### ### ######### ######### ######### ###########################
## union
# cases: no intersection, partial intersection, equal sets, subsets
# and always a varying number of duplicates.

# ### ### ### ######### ######### ######### ###########################
## intersect

# ### ### ### ######### ######### ######### ###########################
## difference

# ### ### ### ######### ######### ######### ###########################
## symdiff

# ### ### ### ######### ######### ######### ###########################
## intersect3

# ### ### ### ######### ######### ######### ###########################
## equal

foreach times $xtime {
    foreach n $xlen {
	set sa [dict get $sx $times $n]
	set sb [dict get $sy $times $n]

	bench -desc "set: equal, yes, shared, $times/$n" -body {
	    struct set equal $sa $sa
	}

	bench -desc "set: equal, yes, distinct, $times/$n" -body {
	    struct set equal $sa $sb
	}

	# sets have no intersection
	bench -desc "set: equal, no, dictinct $times/$n" -body {
	    struct set equal $sa {a b c d e}
	}

	# second set is either true subset, or true superset
	bench -desc "set: equal, no, overlap $times/$n" -body {
	    struct set equal $sa {1 2 3 4}
	}
    }
}

# ### ### ### ######### ######### ######### ###########################
## include, add

foreach times $xtime {
    foreach n $xlen {

	# Adding/including known items should be fast, as nothing
	# changes. It should even be fast in case of a shared
	# object. Which we have in A btw.

	bench -desc "set: include, known $times/$n" -pre {
	    set A [dict get $sx $times $n]
	    struct set include $A x
	} -body {
	    struct set include $A x
	} -post {
	    unset A
	}
	bench -desc "set: add, known $times/$n" -pre {
	    set A [dict get $sx $times $n]
	    struct set add A {a b c d e}
	} -body {
	    struct set add A {a b c d e}
	} -post {
	    unset A
	}

	# Now adding/including items not yet in the set is affected
	# much more by the environment. I.e: Is the object shared ?
	# And: Is the object already in set-type ? Four possibilities.

	# (a) S/U - shared/unshared
	# (b) S/C - set/string (c for conversion required)

	# Notes on the results:
	#
	# I.   <SC> - duplication&conversion - time goes up with set size
	# II.  <SS> - duplication            - s.a
	# III. <UC> - conversion             - s.a, but with larger constant
	# IV.  <US> - near constant - likely linear in the size of the set added.
	#
	# The times for I-III ramp up rapidly enough to make Critcl
	# slower than Tcl for a constant set containing somewhere between
	# 100-1000 elements. This however is only of consequence to
	# one-shot set operations. In case of multiple operations only
	# the first one incurs the above costs, any operation coming
	# after is fast, see IV. I.e.Tcl keeps on adding large times
	# to the total, Critcl otoh goes flat. IOW Critcl may incur a
	# high startup cost when starting with large constant sets,
	# but amortizes this then over all future operations.

	# Note 2: Most of the other benchmarks do not measure
	# conversion time, because the first untimed execution of a
	# body forces not only bc compilation of the script, but also
	# the input to set-type already (values held in the array
	# 'sx').

	# --

	# I. shared string-type <SC>

	bench -desc "set: include, missing <SC> $times/$n" -ipre {
	    set A [dict get $sx $times $n]
	    set B $A
	} -body {
	    struct set include $A x
	} -ipost {
	    unset A B
	}
	bench -desc "set: add, missing <SC> $times/$n" -ipre {
	    set A [dict get $sx $times $n]
	    set B $A
	} -body {
	    struct set add A {a b c d e}
	} -ipost {
	    unset A B
	}

	# II. shared set-type <SS>

	bench -desc "set: include, missing <SS> $times/$n" -ipre {
	    set A [dict get $sx $times $n]
	} -body {
	    struct set include $A x
	} -ipost {
	    unset A
	}
	bench -desc "set: add, missing <SS> $times/$n" -ipre {
	    set A [dict get $sx $times $n]
	} -body {
	    struct set add A {a b c d e}
	} -ipost {
	    unset A
	}

	# III. unshared string-type <UC>

	bench -desc "set: include, missing <UC> $times/$n" -ipre {
	    # string range creates new unshared duplicate in A.
	    set A [string range [dict get $sx $times $n] 1 end]
	} -body {
	    struct set include $A x
	} -ipost {
	    unset A
	}
	bench -desc "set: add, missing <UC> $times/$n" -ipre {
	    set A [string range [dict get $sx $times $n] 1 end]
	} -body {
	    struct set add A {a b c d e}
	} -ipost {
	    unset A
	}

	# IV. unshared set-type <US>

	bench -desc "set: include, missing <US> $times/$n" -ipre {
	    # string range creates new unshared duplicate in A.
	    # Adding the empty set forces the value of A to set-type.
	    set A [string range [dict get $sx $times $n] 1 end]
	    struct set add A {}
	} -body {
	    struct set include $A x
	} -ipost {
	    unset A
	}
	bench -desc "set: add, missing <US> $times/$n" -ipre {
	    set A [string range [dict get $sx $times $n] 1 end]
	    struct set add A {}
	} -body {
	    struct set add A {a b c d e}
	} -ipost {
	    unset A
	}
    }
}

# ### ### ### ######### ######### ######### ###########################
## exclude, subtract

foreach times $xtime {
    foreach n $xlen {

	# Subtracting/excluding unknown items should be fast, as
	# nothing changes. It should even be fast in case of a shared
	# object. Which we have in A btw.

	bench -desc "set: exclude, missing $times/$n" -pre {
	    set A [dict get $sx $times $n]
	} -body {
	    struct set exclude $A x
	} -post {
	    unset A
	}
	bench -desc "set: subtract, missing $times/$n" -pre {
	    set A [dict get $sx $times $n]
	} -body {
	    struct set subtract A {a b c d e}
	} -post {
	    unset A
	}

	# Now subtracting/excluding items in the set is affected
	# much more by the environment. I.e: Is the object shared ?
	# And: Is the object already in set-type ? Four possibilities.

	# See above for discussion.
	# --

	# I. shared string-type <SC>

	bench -desc "set: exclude, known <SC> $times/$n" -ipre {
	    set A [dict get $sx $times $n]
	    set B $A
	} -body {
	    struct set exclude $A 1
	} -ipost {
	    unset A B
	}
	bench -desc "set: subtract, known <SC> $times/$n" -ipre {
	    set A [dict get $sx $times $n]
	    set B $A
	} -body {
	    struct set subtract A {1 2 3 4 5}
	} -ipost {
	    unset A B
	}

	# II. shared set-type <SS>

	bench -desc "set: exclude, known <SS> $times/$n" -ipre {
	    set A [dict get $sx $times $n]
	} -body {
	    struct set exclude $A 1
	} -ipost {
	    unset A
	}
	bench -desc "set: subtract, known <SS> $times/$n" -ipre {
	    set A [dict get $sx $times $n]
	} -body {
	    struct set subtract A {1 2 3 4 5}
	} -ipost {
	    unset A
	}

	# III. unshared string-type <UC>

	bench -desc "set: exclude, known <UC> $times/$n" -ipre {
	    # string range creates new unshared duplicate in A.
	    set A [string range [dict get $sx $times $n] 1 end]
	} -body {
	    struct set exclude $A 1
	} -ipost {
	    unset A
	}

	bench -desc "set: subtract, known <UC> $times/$n" -ipre {
	    set A [string range [dict get $sx $times $n] 1 end]
	} -body {
	    struct set subtract A {1 2 3 4 5}
	} -ipost {
	    unset A
	}

	# IV. unshared set-type <US>

	bench -desc "set: exclude, known <US> $times/$n" -ipre {
	    # string range creates new unshared duplicate in A.
	    # Adding the empty set forces the value of A to set-type.
	    set A [string range [dict get $sx $times $n] 1 end]
	    struct set add A {}
	} -body {
	    struct set exclude $A 1
	} -ipost {
	    unset A
	}

	bench -desc "set: subtract, known <US> $times/$n" -ipre {
	    set A [string range [dict get $sx $times $n] 1 end]
	    struct set add A {}
	} -body {
	    struct set subtract A {1 2 3 4 5}
	} -ipost {
	    unset A
	}
    }
}

# ### ### ### ######### ######### ######### ###########################
## subset

# ### ### ### ######### ######### ######### ###########################
## Complete

return

# ### ### ### ######### ######### ######### ###########################
## Notes ...
